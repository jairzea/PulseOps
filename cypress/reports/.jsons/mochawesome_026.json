{
  "stats": {
    "suites": 1,
    "tests": 5,
    "passes": 0,
    "pending": 0,
    "failures": 5,
    "start": "2026-01-22T21:37:02.365Z",
    "end": "2026-01-22T21:39:50.928Z",
    "duration": 168563,
    "testsRegistered": 5,
    "passPercent": 0,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "4dca0562-945b-401b-9440-ea2341a0f965",
      "title": "",
      "fullFile": "cypress/e2e/features/pulseops/04-metrics.feature",
      "file": "cypress/e2e/features/pulseops/04-metrics.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "b3a6127c-b00b-4661-83d9-dbee755d9185",
          "title": "Gestión de Métricas en PulseOps",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Ver lista de métricas existentes",
              "fullTitle": "Gestión de Métricas en PulseOps Ver lista de métricas existentes",
              "timedOut": null,
              "duration": 12660,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a2, _b2, _c2, _d, _e;\n(0, assertions_1.assert)(context.includedPickles[0].id === pickle.id, \"Included pickle stack is unsynchronized\");\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nconst onAfterStep = (options) => {\n  var _a3, _b3, _c3;\n  const { testStepId, testStepResult } = options;\n  const end = (0, messages_1.createTimestamp)();\n  if (testStepResult.status === messages.TestStepResultStatus.PENDING || testStepResult.status === messages.TestStepResultStatus.SKIPPED) {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: end\n    });\n    remainingSteps.shift();\n    for (const skippedStep of remainingSteps) {\n      const hookIdOrPickleStepId = (0, assertions_1.ensure)((_b3 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b3 !== void 0 ? _b3 : (_c3 = skippedStep.pickleStep) === null || _c3 === void 0 ? void 0 : _c3.id, \"Expected a step to either be a hook or a pickleStep\");\n      const testStepId2 = getTestStepId({\n        context,\n        pickleId: pickle.id,\n        hookIdOrPickleStepId\n      });\n      taskTestStepStarted(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n      taskTestStepFinished(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.SKIPPED,\n          duration: {\n            seconds: 0,\n            nanos: 0\n          }\n        },\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n    }\n    for (let i = 0, count = remainingSteps.length; i < count; i++) {\n      remainingSteps.pop();\n    }\n    cy.then(() => this.skip());\n  } else {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: (0, messages_1.createTimestamp)()\n    });\n    remainingSteps.shift();\n  }\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() => {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const options = {\n        pickle,\n        gherkinDocument,\n        testCaseStartedId\n      };\n      return (0, cypress_1.runStepWithLogGroup)({\n        fn: dryRun ? noopFn : () => registry2.runCaseHook(this, hook, options),\n        keyword: hook.keyword,\n        text: createStepDescription(hook)\n      }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n        return { start, status };\n      });\n    }).then(({ start, status }) => onAfterStep({\n      testStepResult: {\n        status,\n        duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n      },\n      testStepId\n    }));\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.ensure)(pickleStep.text, \"Expected pickle step to have a text\");\n    const scenarioStep = (0, assertions_1.ensure)(context.astIdsMap.get((0, assertions_1.ensure)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b2 = pickleStep.astNodeIds) === null || _b2 === void 0 ? void 0 : _b2[0]}`);\n    const argument = ((_c2 = pickleStep.argument) === null || _c2 === void 0 ? void 0 : _c2.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() => {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = () => beforeStepHooks.reduce((chain, beforeStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"BeforeStep\",\n            text: createStepDescription(beforeStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, beforeStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], { log: false }));\n      const afterStepHooksChain = () => afterStepHooks.reduce((chain, afterStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"AfterStep\",\n            text: createStepDescription(afterStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, afterStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], {\n        log: false\n      }));\n      return beforeHooksChain().then((beforeStepHookResults) => {\n        return (0, cypress_1.runStepWithLogGroup)({\n          keyword: (0, assertions_1.ensure)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n          argument,\n          text,\n          fn: () => {\n            var _a3, _b3;\n            try {\n              return registry2.runStepDefinition(this, text, dryRun, argument);\n            } catch (e) {\n              if (e instanceof registry_1.MissingDefinitionError || e instanceof registry_1.MultipleDefinitionsError) {\n                this.test._retries = this.test._currentRetry;\n              }\n              if (e instanceof registry_1.MissingDefinitionError) {\n                let parameterType = null;\n                if ((_a3 = pickleStep.argument) === null || _a3 === void 0 ? void 0 : _a3.dataTable) {\n                  parameterType = \"dataTable\";\n                } else if ((_b3 = pickleStep.argument) === null || _b3 === void 0 ? void 0 : _b3.docString) {\n                  parameterType = \"docString\";\n                }\n                const snippets = new cucumber_expressions_1.CucumberExpressionGenerator(() => context.registry.parameterTypeRegistry.parameterTypes).generateExpressions(pickleStep.text).map((expression) => (0, snippets_1.generateSnippet)(expression, (0, assertions_1.ensure)(pickleStep.type, \"Expected pickleStep to have a type\"), parameterType));\n                return taskSuggestion(context, {\n                  id: context.newId(),\n                  pickleStepId: pickleStep.id,\n                  snippets: snippets.map((code) => {\n                    return {\n                      language: \"javascript\",\n                      code\n                    };\n                  })\n                }).then(() => {\n                  throw new Error(createMissingStepDefinitionMessage(context, pickleStep, snippets));\n                });\n              } else {\n                throw e;\n              }\n            }\n          }\n        }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n          const testStepResult = {\n            status,\n            duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n          };\n          return {\n            beforeStepHookResults,\n            testStepResult\n          };\n        });\n      }).then(({ beforeStepHookResults, testStepResult }) => {\n        return afterStepHooksChain().then((afterStepHookResults) => {\n          return messages.getWorstTestStepResult([\n            ...beforeStepHookResults,\n            testStepResult,\n            ...afterStepHookResults\n          ]);\n        });\n      });\n    }).then((testStepResult) => onAfterStep({ testStepResult, testStepId }));\n  }\n}",
              "err": {
                "message": "AssertionError: Timed out retrying after 10000ms: expected '[ <th.px-6.py-3.text-left.text-xs.font-medium.text-gray-600.dark:text-gray-400.uppercase.tracking-wider>, 4 more... ]' to contain 'Nombre'",
                "estack": "AssertionError: Timed out retrying after 10000ms: expected '[ <th.px-6.py-3.text-left.text-xs.font-medium.text-gray-600.dark:text-gray-400.uppercase.tracking-wider>, 4 more... ]' to contain 'Nombre'\n    at eval (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:17919:49)\nat Array.forEach (<anonymous>)\n    at MetricsPage.verifyTableColumns (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:17918:19)\n    at Context.eval (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:18022:21)\n    at Registry.runStepDefinition (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:9471:48)\n    at Object.fn (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:15974:42)\n    at runStepWithLogGroup (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:14933:29)\n    at Context.eval (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:15967:60)\n    at getRet (http://localhost:5173/__cypress/runner/cypress_runner.js:122690:20)",
                "diff": null
              },
              "uuid": "8132d345-531f-4b64-a821-86d10d14ec5d",
              "parentUUID": "b3a6127c-b00b-4661-83d9-dbee755d9185",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "Crear una nueva métrica",
              "fullTitle": "Gestión de Métricas en PulseOps Crear una nueva métrica",
              "timedOut": null,
              "duration": 2670,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a2, _b2, _c2, _d, _e;\n(0, assertions_1.assert)(context.includedPickles[0].id === pickle.id, \"Included pickle stack is unsynchronized\");\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nconst onAfterStep = (options) => {\n  var _a3, _b3, _c3;\n  const { testStepId, testStepResult } = options;\n  const end = (0, messages_1.createTimestamp)();\n  if (testStepResult.status === messages.TestStepResultStatus.PENDING || testStepResult.status === messages.TestStepResultStatus.SKIPPED) {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: end\n    });\n    remainingSteps.shift();\n    for (const skippedStep of remainingSteps) {\n      const hookIdOrPickleStepId = (0, assertions_1.ensure)((_b3 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b3 !== void 0 ? _b3 : (_c3 = skippedStep.pickleStep) === null || _c3 === void 0 ? void 0 : _c3.id, \"Expected a step to either be a hook or a pickleStep\");\n      const testStepId2 = getTestStepId({\n        context,\n        pickleId: pickle.id,\n        hookIdOrPickleStepId\n      });\n      taskTestStepStarted(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n      taskTestStepFinished(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.SKIPPED,\n          duration: {\n            seconds: 0,\n            nanos: 0\n          }\n        },\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n    }\n    for (let i = 0, count = remainingSteps.length; i < count; i++) {\n      remainingSteps.pop();\n    }\n    cy.then(() => this.skip());\n  } else {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: (0, messages_1.createTimestamp)()\n    });\n    remainingSteps.shift();\n  }\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() => {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const options = {\n        pickle,\n        gherkinDocument,\n        testCaseStartedId\n      };\n      return (0, cypress_1.runStepWithLogGroup)({\n        fn: dryRun ? noopFn : () => registry2.runCaseHook(this, hook, options),\n        keyword: hook.keyword,\n        text: createStepDescription(hook)\n      }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n        return { start, status };\n      });\n    }).then(({ start, status }) => onAfterStep({\n      testStepResult: {\n        status,\n        duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n      },\n      testStepId\n    }));\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.ensure)(pickleStep.text, \"Expected pickle step to have a text\");\n    const scenarioStep = (0, assertions_1.ensure)(context.astIdsMap.get((0, assertions_1.ensure)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b2 = pickleStep.astNodeIds) === null || _b2 === void 0 ? void 0 : _b2[0]}`);\n    const argument = ((_c2 = pickleStep.argument) === null || _c2 === void 0 ? void 0 : _c2.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() => {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = () => beforeStepHooks.reduce((chain, beforeStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"BeforeStep\",\n            text: createStepDescription(beforeStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, beforeStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], { log: false }));\n      const afterStepHooksChain = () => afterStepHooks.reduce((chain, afterStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"AfterStep\",\n            text: createStepDescription(afterStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, afterStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], {\n        log: false\n      }));\n      return beforeHooksChain().then((beforeStepHookResults) => {\n        return (0, cypress_1.runStepWithLogGroup)({\n          keyword: (0, assertions_1.ensure)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n          argument,\n          text,\n          fn: () => {\n            var _a3, _b3;\n            try {\n              return registry2.runStepDefinition(this, text, dryRun, argument);\n            } catch (e) {\n              if (e instanceof registry_1.MissingDefinitionError || e instanceof registry_1.MultipleDefinitionsError) {\n                this.test._retries = this.test._currentRetry;\n              }\n              if (e instanceof registry_1.MissingDefinitionError) {\n                let parameterType = null;\n                if ((_a3 = pickleStep.argument) === null || _a3 === void 0 ? void 0 : _a3.dataTable) {\n                  parameterType = \"dataTable\";\n                } else if ((_b3 = pickleStep.argument) === null || _b3 === void 0 ? void 0 : _b3.docString) {\n                  parameterType = \"docString\";\n                }\n                const snippets = new cucumber_expressions_1.CucumberExpressionGenerator(() => context.registry.parameterTypeRegistry.parameterTypes).generateExpressions(pickleStep.text).map((expression) => (0, snippets_1.generateSnippet)(expression, (0, assertions_1.ensure)(pickleStep.type, \"Expected pickleStep to have a type\"), parameterType));\n                return taskSuggestion(context, {\n                  id: context.newId(),\n                  pickleStepId: pickleStep.id,\n                  snippets: snippets.map((code) => {\n                    return {\n                      language: \"javascript\",\n                      code\n                    };\n                  })\n                }).then(() => {\n                  throw new Error(createMissingStepDefinitionMessage(context, pickleStep, snippets));\n                });\n              } else {\n                throw e;\n              }\n            }\n          }\n        }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n          const testStepResult = {\n            status,\n            duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n          };\n          return {\n            beforeStepHookResults,\n            testStepResult\n          };\n        });\n      }).then(({ beforeStepHookResults, testStepResult }) => {\n        return afterStepHooksChain().then((afterStepHookResults) => {\n          return messages.getWorstTestStepResult([\n            ...beforeStepHookResults,\n            testStepResult,\n            ...afterStepHookResults\n          ]);\n        });\n      });\n    }).then((testStepResult) => onAfterStep({ testStepResult, testStepId }));\n  }\n}",
              "err": {
                "message": "Error: Multiple matching step definitions for: hace clic en el botón \"Crear Métrica\"\n hace clic en el botón {string}\n hace clic en el botón {string}\n hace clic en el botón {string}",
                "estack": "Error: Multiple matching step definitions for: hace clic en el botón \"Crear Métrica\"\n hace clic en el botón {string}\n hace clic en el botón {string}\n hace clic en el botón {string}\n    at Registry.resolveStepDefinition (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:9448:19)\n    at Registry.runStepDefinition (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:9463:39)\n    at Object.fn (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:15974:42)\n    at runStepWithLogGroup (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:14933:29)\n    at Context.eval (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:15967:60)\n    at getRet (http://localhost:5173/__cypress/runner/cypress_runner.js:122690:20)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise.attempt.Promise.try (http://localhost:5173/__cypress/runner/cypress_runner.js:4285:29)\n    at Context.thenFn (http://localhost:5173/__cypress/runner/cypress_runner.js:122701:66)\n    at Context.then (http://localhost:5173/__cypress/runner/cypress_runner.js:122952:21)",
                "diff": null
              },
              "uuid": "6d1afcab-57cd-4a83-b6d4-958d4858f36e",
              "parentUUID": "b3a6127c-b00b-4661-83d9-dbee755d9185",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "Buscar una métrica específica",
              "fullTitle": "Gestión de Métricas en PulseOps Buscar una métrica específica",
              "timedOut": null,
              "duration": 14482,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a2, _b2, _c2, _d, _e;\n(0, assertions_1.assert)(context.includedPickles[0].id === pickle.id, \"Included pickle stack is unsynchronized\");\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nconst onAfterStep = (options) => {\n  var _a3, _b3, _c3;\n  const { testStepId, testStepResult } = options;\n  const end = (0, messages_1.createTimestamp)();\n  if (testStepResult.status === messages.TestStepResultStatus.PENDING || testStepResult.status === messages.TestStepResultStatus.SKIPPED) {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: end\n    });\n    remainingSteps.shift();\n    for (const skippedStep of remainingSteps) {\n      const hookIdOrPickleStepId = (0, assertions_1.ensure)((_b3 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b3 !== void 0 ? _b3 : (_c3 = skippedStep.pickleStep) === null || _c3 === void 0 ? void 0 : _c3.id, \"Expected a step to either be a hook or a pickleStep\");\n      const testStepId2 = getTestStepId({\n        context,\n        pickleId: pickle.id,\n        hookIdOrPickleStepId\n      });\n      taskTestStepStarted(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n      taskTestStepFinished(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.SKIPPED,\n          duration: {\n            seconds: 0,\n            nanos: 0\n          }\n        },\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n    }\n    for (let i = 0, count = remainingSteps.length; i < count; i++) {\n      remainingSteps.pop();\n    }\n    cy.then(() => this.skip());\n  } else {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: (0, messages_1.createTimestamp)()\n    });\n    remainingSteps.shift();\n  }\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() => {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const options = {\n        pickle,\n        gherkinDocument,\n        testCaseStartedId\n      };\n      return (0, cypress_1.runStepWithLogGroup)({\n        fn: dryRun ? noopFn : () => registry2.runCaseHook(this, hook, options),\n        keyword: hook.keyword,\n        text: createStepDescription(hook)\n      }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n        return { start, status };\n      });\n    }).then(({ start, status }) => onAfterStep({\n      testStepResult: {\n        status,\n        duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n      },\n      testStepId\n    }));\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.ensure)(pickleStep.text, \"Expected pickle step to have a text\");\n    const scenarioStep = (0, assertions_1.ensure)(context.astIdsMap.get((0, assertions_1.ensure)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b2 = pickleStep.astNodeIds) === null || _b2 === void 0 ? void 0 : _b2[0]}`);\n    const argument = ((_c2 = pickleStep.argument) === null || _c2 === void 0 ? void 0 : _c2.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() => {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = () => beforeStepHooks.reduce((chain, beforeStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"BeforeStep\",\n            text: createStepDescription(beforeStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, beforeStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], { log: false }));\n      const afterStepHooksChain = () => afterStepHooks.reduce((chain, afterStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"AfterStep\",\n            text: createStepDescription(afterStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, afterStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], {\n        log: false\n      }));\n      return beforeHooksChain().then((beforeStepHookResults) => {\n        return (0, cypress_1.runStepWithLogGroup)({\n          keyword: (0, assertions_1.ensure)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n          argument,\n          text,\n          fn: () => {\n            var _a3, _b3;\n            try {\n              return registry2.runStepDefinition(this, text, dryRun, argument);\n            } catch (e) {\n              if (e instanceof registry_1.MissingDefinitionError || e instanceof registry_1.MultipleDefinitionsError) {\n                this.test._retries = this.test._currentRetry;\n              }\n              if (e instanceof registry_1.MissingDefinitionError) {\n                let parameterType = null;\n                if ((_a3 = pickleStep.argument) === null || _a3 === void 0 ? void 0 : _a3.dataTable) {\n                  parameterType = \"dataTable\";\n                } else if ((_b3 = pickleStep.argument) === null || _b3 === void 0 ? void 0 : _b3.docString) {\n                  parameterType = \"docString\";\n                }\n                const snippets = new cucumber_expressions_1.CucumberExpressionGenerator(() => context.registry.parameterTypeRegistry.parameterTypes).generateExpressions(pickleStep.text).map((expression) => (0, snippets_1.generateSnippet)(expression, (0, assertions_1.ensure)(pickleStep.type, \"Expected pickleStep to have a type\"), parameterType));\n                return taskSuggestion(context, {\n                  id: context.newId(),\n                  pickleStepId: pickleStep.id,\n                  snippets: snippets.map((code) => {\n                    return {\n                      language: \"javascript\",\n                      code\n                    };\n                  })\n                }).then(() => {\n                  throw new Error(createMissingStepDefinitionMessage(context, pickleStep, snippets));\n                });\n              } else {\n                throw e;\n              }\n            }\n          }\n        }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n          const testStepResult = {\n            status,\n            duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n          };\n          return {\n            beforeStepHookResults,\n            testStepResult\n          };\n        });\n      }).then(({ beforeStepHookResults, testStepResult }) => {\n        return afterStepHooksChain().then((afterStepHookResults) => {\n          return messages.getWorstTestStepResult([\n            ...beforeStepHookResults,\n            testStepResult,\n            ...afterStepHookResults\n          ]);\n        });\n      });\n    }).then((testStepResult) => onAfterStep({ testStepResult, testStepId }));\n  }\n}",
              "err": {
                "message": "CypressError: Timed out retrying after 10000ms: `cy.should()` failed because the page updated as a result of this command, but you tried to continue the command chain. The subject is no longer attached to the DOM, and Cypress cannot requery the page after commands such as `cy.should()`.\n\nCommon situations why this happens:\n  - Your JS framework re-rendered asynchronously\n  - Your app code reacted to an event firing and removed the element\n\nYou can typically solve this by breaking up a chain. For example, rewrite:\n\n> `cy.get('button').click().should('have.class', 'active')`\n\nto\n\n> `cy.get('button').as('btn').click()`\n> `cy.get('@btn').should('have.class', 'active')`\n\nhttps://on.cypress.io/element-has-detached-from-dom",
                "estack": "CypressError: Timed out retrying after 10000ms: `cy.should()` failed because the page updated as a result of this command, but you tried to continue the command chain. The subject is no longer attached to the DOM, and Cypress cannot requery the page after commands such as `cy.should()`.\n\nCommon situations why this happens:\n  - Your JS framework re-rendered asynchronously\n  - Your app code reacted to an event firing and removed the element\n\nYou can typically solve this by breaking up a chain. For example, rewrite:\n\n> `cy.get('button').click().should('have.class', 'active')`\n\nto\n\n> `cy.get('button').as('btn').click()`\n> `cy.get('@btn').should('have.class', 'active')`\n\nhttps://on.cypress.io/element-has-detached-from-dom\n    at Object.isAttached (http://localhost:5173/__cypress/runner/cypress_runner.js:152942:58)\n    at applyChainers (http://localhost:5173/__cypress/runner/cypress_runner.js:122225:24)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise.attempt.Promise.try (http://localhost:5173/__cypress/runner/cypress_runner.js:4285:29)\n    at Context.shouldFn (http://localhost:5173/__cypress/runner/cypress_runner.js:122253:66)\n    at Context.should (http://localhost:5173/__cypress/runner/cypress_runner.js:122270:23)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:151005:39)\n    at assertions (http://localhost:5173/__cypress/runner/cypress_runner.js:151253:16)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Object.gotValue (http://localhost:5173/__cypress/runner/cypress_runner.js:6448:18)\n    at Object.gotAccum (http://localhost:5173/__cypress/runner/cypress_runner.js:6435:25)\n    at Object.tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise._settlePromiseFromHandler (http://localhost:5173/__cypress/runner/cypress_runner.js:1489:31)\n    at Promise._settlePromise (http://localhost:5173/__cypress/runner/cypress_runner.js:1546:18)\n    at Promise._settlePromiseCtx (http://localhost:5173/__cypress/runner/cypress_runner.js:1583:10)\n    at _drainQueueStep (http://localhost:5173/__cypress/runner/cypress_runner.js:2381:12)\n    at _drainQueue (http://localhost:5173/__cypress/runner/cypress_runner.js:2370:9)\n    at Async._drainQueues (http://localhost:5173/__cypress/runner/cypress_runner.js:2386:5)\n    at Async.drainQueues (http://localhost:5173/__cypress/runner/cypress_runner.js:2256:14)\nFrom Your Spec Code:\n    at Context.eval (http://localhost:5173/__cypress/tests?p=cypress/e2e/features/pulseops/04-metrics.feature:17992:27)\n    at Context.callback (http://localhost:5173/__cypress/runner/cypress_runner.js:122925:26)\n    at getRet (http://localhost:5173/__cypress/runner/cypress_runner.js:122690:20)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise.attempt.Promise.try (http://localhost:5173/__cypress/runner/cypress_runner.js:4285:29)\n    at thenFn (http://localhost:5173/__cypress/runner/cypress_runner.js:122701:66)\n    at yieldItem (http://localhost:5173/__cypress/runner/cypress_runner.js:122933:16)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Object.gotValue (http://localhost:5173/__cypress/runner/cypress_runner.js:6446:18)",
                "diff": null
              },
              "uuid": "bfcd0d4b-7777-4b2c-886f-37c3d5010763",
              "parentUUID": "b3a6127c-b00b-4661-83d9-dbee755d9185",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "Editar una métrica existente",
              "fullTitle": "Gestión de Métricas en PulseOps Editar una métrica existente",
              "timedOut": null,
              "duration": 14166,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a2, _b2, _c2, _d, _e;\n(0, assertions_1.assert)(context.includedPickles[0].id === pickle.id, \"Included pickle stack is unsynchronized\");\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nconst onAfterStep = (options) => {\n  var _a3, _b3, _c3;\n  const { testStepId, testStepResult } = options;\n  const end = (0, messages_1.createTimestamp)();\n  if (testStepResult.status === messages.TestStepResultStatus.PENDING || testStepResult.status === messages.TestStepResultStatus.SKIPPED) {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: end\n    });\n    remainingSteps.shift();\n    for (const skippedStep of remainingSteps) {\n      const hookIdOrPickleStepId = (0, assertions_1.ensure)((_b3 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b3 !== void 0 ? _b3 : (_c3 = skippedStep.pickleStep) === null || _c3 === void 0 ? void 0 : _c3.id, \"Expected a step to either be a hook or a pickleStep\");\n      const testStepId2 = getTestStepId({\n        context,\n        pickleId: pickle.id,\n        hookIdOrPickleStepId\n      });\n      taskTestStepStarted(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n      taskTestStepFinished(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.SKIPPED,\n          duration: {\n            seconds: 0,\n            nanos: 0\n          }\n        },\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n    }\n    for (let i = 0, count = remainingSteps.length; i < count; i++) {\n      remainingSteps.pop();\n    }\n    cy.then(() => this.skip());\n  } else {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: (0, messages_1.createTimestamp)()\n    });\n    remainingSteps.shift();\n  }\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() => {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const options = {\n        pickle,\n        gherkinDocument,\n        testCaseStartedId\n      };\n      return (0, cypress_1.runStepWithLogGroup)({\n        fn: dryRun ? noopFn : () => registry2.runCaseHook(this, hook, options),\n        keyword: hook.keyword,\n        text: createStepDescription(hook)\n      }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n        return { start, status };\n      });\n    }).then(({ start, status }) => onAfterStep({\n      testStepResult: {\n        status,\n        duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n      },\n      testStepId\n    }));\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.ensure)(pickleStep.text, \"Expected pickle step to have a text\");\n    const scenarioStep = (0, assertions_1.ensure)(context.astIdsMap.get((0, assertions_1.ensure)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b2 = pickleStep.astNodeIds) === null || _b2 === void 0 ? void 0 : _b2[0]}`);\n    const argument = ((_c2 = pickleStep.argument) === null || _c2 === void 0 ? void 0 : _c2.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() => {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = () => beforeStepHooks.reduce((chain, beforeStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"BeforeStep\",\n            text: createStepDescription(beforeStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, beforeStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], { log: false }));\n      const afterStepHooksChain = () => afterStepHooks.reduce((chain, afterStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"AfterStep\",\n            text: createStepDescription(afterStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, afterStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], {\n        log: false\n      }));\n      return beforeHooksChain().then((beforeStepHookResults) => {\n        return (0, cypress_1.runStepWithLogGroup)({\n          keyword: (0, assertions_1.ensure)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n          argument,\n          text,\n          fn: () => {\n            var _a3, _b3;\n            try {\n              return registry2.runStepDefinition(this, text, dryRun, argument);\n            } catch (e) {\n              if (e instanceof registry_1.MissingDefinitionError || e instanceof registry_1.MultipleDefinitionsError) {\n                this.test._retries = this.test._currentRetry;\n              }\n              if (e instanceof registry_1.MissingDefinitionError) {\n                let parameterType = null;\n                if ((_a3 = pickleStep.argument) === null || _a3 === void 0 ? void 0 : _a3.dataTable) {\n                  parameterType = \"dataTable\";\n                } else if ((_b3 = pickleStep.argument) === null || _b3 === void 0 ? void 0 : _b3.docString) {\n                  parameterType = \"docString\";\n                }\n                const snippets = new cucumber_expressions_1.CucumberExpressionGenerator(() => context.registry.parameterTypeRegistry.parameterTypes).generateExpressions(pickleStep.text).map((expression) => (0, snippets_1.generateSnippet)(expression, (0, assertions_1.ensure)(pickleStep.type, \"Expected pickleStep to have a type\"), parameterType));\n                return taskSuggestion(context, {\n                  id: context.newId(),\n                  pickleStepId: pickleStep.id,\n                  snippets: snippets.map((code) => {\n                    return {\n                      language: \"javascript\",\n                      code\n                    };\n                  })\n                }).then(() => {\n                  throw new Error(createMissingStepDefinitionMessage(context, pickleStep, snippets));\n                });\n              } else {\n                throw e;\n              }\n            }\n          }\n        }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n          const testStepResult = {\n            status,\n            duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n          };\n          return {\n            beforeStepHookResults,\n            testStepResult\n          };\n        });\n      }).then(({ beforeStepHookResults, testStepResult }) => {\n        return afterStepHooksChain().then((afterStepHookResults) => {\n          return messages.getWorstTestStepResult([\n            ...beforeStepHookResults,\n            testStepResult,\n            ...afterStepHookResults\n          ]);\n        });\n      });\n    }).then((testStepResult) => onAfterStep({ testStepResult, testStepId }));\n  }\n}",
              "err": {
                "message": "Error: Timed out retrying after 10000ms: Syntax error, unrecognized expression: button:contains(\"Editar\"), button:contains(\"Edit\"), [aria-label*=\"edit\" i]",
                "estack": "Error: Timed out retrying after 10000ms: Syntax error, unrecognized expression: button:contains(\"Editar\"), button:contains(\"Edit\"), [aria-label*=\"edit\" i]\n    at find.error (http://localhost:5173/__cypress/runner/cypress_runner.js:8298:8)\n    at tokenize (http://localhost:5173/__cypress/runner/cypress_runner.js:8964:8)\n    at jQuery.find (http://localhost:5173/__cypress/runner/cypress_runner.js:7708:15)\n    at jQuery.fn.init.find (http://localhost:5173/__cypress/runner/cypress_runner.js:9633:11)\n    at getEl (http://localhost:5173/__cypress/runner/cypress_runner.js:138522:31)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:138559:21)\n    at Object.subjectFn (http://localhost:5173/__cypress/runner/cypress_runner.js:151868:16)\n    at $Cy.verifyUpcomingAssertions (http://localhost:5173/__cypress/runner/cypress_runner.js:151196:31)\n    at onRetry (http://localhost:5173/__cypress/runner/cypress_runner.js:151859:15)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise.attempt.Promise.try (http://localhost:5173/__cypress/runner/cypress_runner.js:4285:29)\n    at whenStable (http://localhost:5173/__cypress/runner/cypress_runner.js:151746:68)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:151687:14)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise._settlePromiseFromHandler (http://localhost:5173/__cypress/runner/cypress_runner.js:1489:31)\n    at Promise._settlePromise (http://localhost:5173/__cypress/runner/cypress_runner.js:1546:18)\n    at Promise._settlePromise0 (http://localhost:5173/__cypress/runner/cypress_runner.js:1591:10)\n    at Promise._settlePromises (http://localhost:5173/__cypress/runner/cypress_runner.js:1671:18)\n    at Promise._fulfill (http://localhost:5173/__cypress/runner/cypress_runner.js:1615:18)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:5420:46)",
                "diff": null
              },
              "uuid": "3bf9f2f9-cc65-48fa-a301-cd999cb89ffe",
              "parentUUID": "b3a6127c-b00b-4661-83d9-dbee755d9185",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "Eliminar una métrica",
              "fullTitle": "Gestión de Métricas en PulseOps Eliminar una métrica",
              "timedOut": null,
              "duration": 12969,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a2, _b2, _c2, _d, _e;\n(0, assertions_1.assert)(context.includedPickles[0].id === pickle.id, \"Included pickle stack is unsynchronized\");\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nconst onAfterStep = (options) => {\n  var _a3, _b3, _c3;\n  const { testStepId, testStepResult } = options;\n  const end = (0, messages_1.createTimestamp)();\n  if (testStepResult.status === messages.TestStepResultStatus.PENDING || testStepResult.status === messages.TestStepResultStatus.SKIPPED) {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: end\n    });\n    remainingSteps.shift();\n    for (const skippedStep of remainingSteps) {\n      const hookIdOrPickleStepId = (0, assertions_1.ensure)((_b3 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b3 !== void 0 ? _b3 : (_c3 = skippedStep.pickleStep) === null || _c3 === void 0 ? void 0 : _c3.id, \"Expected a step to either be a hook or a pickleStep\");\n      const testStepId2 = getTestStepId({\n        context,\n        pickleId: pickle.id,\n        hookIdOrPickleStepId\n      });\n      taskTestStepStarted(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n      taskTestStepFinished(context, {\n        testStepId: testStepId2,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.SKIPPED,\n          duration: {\n            seconds: 0,\n            nanos: 0\n          }\n        },\n        timestamp: (0, messages_1.createTimestamp)()\n      });\n    }\n    for (let i = 0, count = remainingSteps.length; i < count; i++) {\n      remainingSteps.pop();\n    }\n    cy.then(() => this.skip());\n  } else {\n    taskTestStepFinished(context, {\n      testStepId,\n      testCaseStartedId,\n      testStepResult,\n      timestamp: (0, messages_1.createTimestamp)()\n    });\n    remainingSteps.shift();\n  }\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() => {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const options = {\n        pickle,\n        gherkinDocument,\n        testCaseStartedId\n      };\n      return (0, cypress_1.runStepWithLogGroup)({\n        fn: dryRun ? noopFn : () => registry2.runCaseHook(this, hook, options),\n        keyword: hook.keyword,\n        text: createStepDescription(hook)\n      }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n        return { start, status };\n      });\n    }).then(({ start, status }) => onAfterStep({\n      testStepResult: {\n        status,\n        duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n      },\n      testStepId\n    }));\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.ensure)(pickleStep.text, \"Expected pickle step to have a text\");\n    const scenarioStep = (0, assertions_1.ensure)(context.astIdsMap.get((0, assertions_1.ensure)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b2 = pickleStep.astNodeIds) === null || _b2 === void 0 ? void 0 : _b2[0]}`);\n    const argument = ((_c2 = pickleStep.argument) === null || _c2 === void 0 ? void 0 : _c2.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() => {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) => {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = () => beforeStepHooks.reduce((chain, beforeStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"BeforeStep\",\n            text: createStepDescription(beforeStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, beforeStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], { log: false }));\n      const afterStepHooksChain = () => afterStepHooks.reduce((chain, afterStepHook) => {\n        return chain.then((results) => {\n          const start2 = (0, messages_1.createTimestamp)();\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: \"AfterStep\",\n            text: createStepDescription(afterStepHook),\n            fn: dryRun ? noopFn : () => registry2.runStepHook(this, afterStepHook, options)\n          }).then(convertReturnValueToTestStepResultStatus).then((status) => results.concat({\n            status,\n            duration: (0, messages_1.duration)(start2, (0, messages_1.createTimestamp)())\n          }));\n        });\n      }, cy.wrap([], {\n        log: false\n      }));\n      return beforeHooksChain().then((beforeStepHookResults) => {\n        return (0, cypress_1.runStepWithLogGroup)({\n          keyword: (0, assertions_1.ensure)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n          argument,\n          text,\n          fn: () => {\n            var _a3, _b3;\n            try {\n              return registry2.runStepDefinition(this, text, dryRun, argument);\n            } catch (e) {\n              if (e instanceof registry_1.MissingDefinitionError || e instanceof registry_1.MultipleDefinitionsError) {\n                this.test._retries = this.test._currentRetry;\n              }\n              if (e instanceof registry_1.MissingDefinitionError) {\n                let parameterType = null;\n                if ((_a3 = pickleStep.argument) === null || _a3 === void 0 ? void 0 : _a3.dataTable) {\n                  parameterType = \"dataTable\";\n                } else if ((_b3 = pickleStep.argument) === null || _b3 === void 0 ? void 0 : _b3.docString) {\n                  parameterType = \"docString\";\n                }\n                const snippets = new cucumber_expressions_1.CucumberExpressionGenerator(() => context.registry.parameterTypeRegistry.parameterTypes).generateExpressions(pickleStep.text).map((expression) => (0, snippets_1.generateSnippet)(expression, (0, assertions_1.ensure)(pickleStep.type, \"Expected pickleStep to have a type\"), parameterType));\n                return taskSuggestion(context, {\n                  id: context.newId(),\n                  pickleStepId: pickleStep.id,\n                  snippets: snippets.map((code) => {\n                    return {\n                      language: \"javascript\",\n                      code\n                    };\n                  })\n                }).then(() => {\n                  throw new Error(createMissingStepDefinitionMessage(context, pickleStep, snippets));\n                });\n              } else {\n                throw e;\n              }\n            }\n          }\n        }).then(convertReturnValueToTestStepResultStatus).then((status) => {\n          const testStepResult = {\n            status,\n            duration: (0, messages_1.duration)(start, (0, messages_1.createTimestamp)())\n          };\n          return {\n            beforeStepHookResults,\n            testStepResult\n          };\n        });\n      }).then(({ beforeStepHookResults, testStepResult }) => {\n        return afterStepHooksChain().then((afterStepHookResults) => {\n          return messages.getWorstTestStepResult([\n            ...beforeStepHookResults,\n            testStepResult,\n            ...afterStepHookResults\n          ]);\n        });\n      });\n    }).then((testStepResult) => onAfterStep({ testStepResult, testStepId }));\n  }\n}",
              "err": {
                "message": "Error: Timed out retrying after 10000ms: Syntax error, unrecognized expression: button:contains(\"Eliminar\"), button:contains(\"Delete\"), [aria-label*=\"delete\" i]",
                "estack": "Error: Timed out retrying after 10000ms: Syntax error, unrecognized expression: button:contains(\"Eliminar\"), button:contains(\"Delete\"), [aria-label*=\"delete\" i]\n    at find.error (http://localhost:5173/__cypress/runner/cypress_runner.js:8298:8)\n    at tokenize (http://localhost:5173/__cypress/runner/cypress_runner.js:8964:8)\n    at jQuery.find (http://localhost:5173/__cypress/runner/cypress_runner.js:7708:15)\n    at jQuery.fn.init.find (http://localhost:5173/__cypress/runner/cypress_runner.js:9633:11)\n    at getEl (http://localhost:5173/__cypress/runner/cypress_runner.js:138522:31)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:138559:21)\n    at Object.subjectFn (http://localhost:5173/__cypress/runner/cypress_runner.js:151868:16)\n    at $Cy.verifyUpcomingAssertions (http://localhost:5173/__cypress/runner/cypress_runner.js:151196:31)\n    at onRetry (http://localhost:5173/__cypress/runner/cypress_runner.js:151859:15)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise.attempt.Promise.try (http://localhost:5173/__cypress/runner/cypress_runner.js:4285:29)\n    at whenStable (http://localhost:5173/__cypress/runner/cypress_runner.js:151746:68)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:151687:14)\n    at tryCatcher (http://localhost:5173/__cypress/runner/cypress_runner.js:1777:23)\n    at Promise._settlePromiseFromHandler (http://localhost:5173/__cypress/runner/cypress_runner.js:1489:31)\n    at Promise._settlePromise (http://localhost:5173/__cypress/runner/cypress_runner.js:1546:18)\n    at Promise._settlePromise0 (http://localhost:5173/__cypress/runner/cypress_runner.js:1591:10)\n    at Promise._settlePromises (http://localhost:5173/__cypress/runner/cypress_runner.js:1671:18)\n    at Promise._fulfill (http://localhost:5173/__cypress/runner/cypress_runner.js:1615:18)\n    at <unknown> (http://localhost:5173/__cypress/runner/cypress_runner.js:5420:46)",
                "diff": null
              },
              "uuid": "191fc5b5-9406-49dc-bb9e-31e915196eb4",
              "parentUUID": "b3a6127c-b00b-4661-83d9-dbee755d9185",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "8132d345-531f-4b64-a821-86d10d14ec5d",
            "6d1afcab-57cd-4a83-b6d4-958d4858f36e",
            "bfcd0d4b-7777-4b2c-886f-37c3d5010763",
            "3bf9f2f9-cc65-48fa-a301-cd999cb89ffe",
            "191fc5b5-9406-49dc-bb9e-31e915196eb4"
          ],
          "pending": [],
          "skipped": [],
          "duration": 56947,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    }
  ],
  "meta": {
    "mocha": {
      "version": "7.2.0"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": false,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.4"
    },
    "marge": {
      "options": {
        "reportDir": "cypress/reports/.jsons",
        "overwrite": false,
        "html": false,
        "json": true,
        "charts": true,
        "reportPageTitle": "PulseOps E2E Test Report",
        "embeddedScreenshots": true,
        "inlineAssets": true
      },
      "version": "6.3.2"
    }
  }
}